package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"

	"github.com/coreos/go-semver/semver"
	"github.com/minio/cli"
	"github.com/pkg/errors"
	"github.com/threefoldtech/bcdb/clients/go/bcdb"
	"google.golang.org/grpc"
)

const (
	// Collection used to store objects
	Collection = "files"
)

func main() {
	app := cli.NewApp()
	app.Usage = "Store an manage file in bcdb"
	app.Version = "0.0.1"
	app.EnableBashCompletion = true

	app.Flags = []cli.Flag{
		cli.BoolFlag{
			Name:  "debug, d",
			Usage: "enable debug logging",
		},
		cli.StringFlag{
			Name:   "seed-file",
			Usage:  "Seed filename. It works with seed files generated by tfuser",
			EnvVar: "SEED_FILE",
		},
		cli.StringFlag{
			Name:   "bcdb, b",
			Usage:  "Address of BCDB",
			Value:  "localhost:50051",
			EnvVar: "BCDB",
		},
	}

	app.Commands = []cli.Command{
		{
			Name:      "ls",
			ArgsUsage: "<directory>",
			Usage:     "list files in a directory",
			Action:    WithConnection(List),
		},
		{
			Name:      "mkdir",
			ArgsUsage: "<directory>",
			Usage:     "make direcotory (equivalent to mkdir -p)",
			Action:    WithConnection(MkdirAll),
		},
		{
			Name:      "put",
			ArgsUsage: "<local> <remote>",
			Usage:     "put file <source> into <destination>",
			Action:    WithConnection(Put),
		},
		{
			Name:      "get",
			ArgsUsage: "<remote> <local>",
			Usage:     "get file <source> into <destination>",
			Action:    WithConnection(Get),
		},
		{
			Name:      "cat",
			ArgsUsage: "<remote>",
			Usage:     "prints content of the file on screen",
			Action:    WithConnection(Cat),
		},
	}

	if err := app.Run(os.Args); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(1)
	}
}

type ActionFunc func(ctx *cli.Context, cl bcdb.BCDBClient) error

func WithConnection(action ActionFunc) cli.ActionFunc {

	return func(ctx *cli.Context) error {
		seedFile, err := os.Open(ctx.GlobalString("seed-file"))
		if err != nil {
			return errors.Wrap(err, "failed to open seed file")
		}
		dec := json.NewDecoder(seedFile)
		var ver semver.Version
		if err := dec.Decode(&ver); err != nil {
			return errors.Wrap(err, "invalid seed file format version not found")
		}
		if !ver.Equal(*semver.New("1.1.0")) {
			return errors.Wrap(err, "invalid seed file version. only support 1.1.0")
		}

		var seed struct {
			Mnemonic string `json:"mnemonic"`
			UserID   uint64 `json:"threebotid"`
		}
		if err := dec.Decode(&seed); err != nil {
			return errors.Wrap(err, "failed to load seed")
		}

		auth, err := bcdb.NewBCDBAuthenticatorFromMnemonic(seed.UserID, string(seed.Mnemonic), bcdb.WithExpiresDuration(3*time.Second))
		if err != nil {
			return errors.Wrap(err, "failed to initialize authorization")
		}

		client, err := grpc.Dial(ctx.GlobalString("bcdb"), grpc.WithInsecure(), grpc.WithPerRPCCredentials(auth))
		if err != nil {
			return errors.Wrap(err, "failed to connect to bcdb")
		}

		cl := bcdb.NewBCDBClient(client)

		return action(ctx, cl)
	}

}

func Cat(ctx *cli.Context, cl bcdb.BCDBClient) error {
	src := ctx.Args().First()

	if len(src) == 0 {
		return fmt.Errorf("file path is missing")
	}

	data, err := download(context.Background(), cl, filepath.Dir(src), filepath.Base(src))

	if err != nil {
		return err
	}

	_, err = os.Stdout.Write(data)

	return err

}

func Get(ctx *cli.Context, cl bcdb.BCDBClient) error {
	if ctx.NArg() != 2 {
		return fmt.Errorf("required <source> <destination>")
	}

	src := ctx.Args().First()
	dst := ctx.Args().Tail()[0]

	data, err := download(context.Background(), cl, filepath.Dir(src), filepath.Base(src))
	if err != nil {
		return err
	}

	return ioutil.WriteFile(dst, data, 0644)
}

func Put(ctx *cli.Context, cl bcdb.BCDBClient) error {
	if ctx.NArg() != 2 {
		return fmt.Errorf("required <source> <destination>")
	}

	src := ctx.Args().First()
	dst := ctx.Args().Tail()[0]

	stat, err := os.Stat(src)
	if err != nil {
		return errors.Wrap(err, "failed to open file")
	}

	if stat.IsDir() {
		return errors.Wrap(err, "source can not be a directory")
	}

	if stat.Size() > 8*1024*1024 {
		return errors.Wrap(err, "we only support max file size of 8M at the moment")
	}

	data, err := ioutil.ReadFile(src)
	if err != nil {
		return errors.Wrap(err, "failed to read file")
	}

	return put(context.Background(), cl, dst, data)
}

func MkdirAll(ctx *cli.Context, cl bcdb.BCDBClient) error {
	dir := ctx.Args().First()
	if len(dir) == 0 {
		return fmt.Errorf("missing directory name")
	}

	return mkdirAll(context.Background(), cl, dir)
}

func List(ctx *cli.Context, cl bcdb.BCDBClient) error {
	dir := ctx.Args().First()

	files, err := list(context.Background(), cl, dir)

	if err != nil {
		return errors.Wrap(err, "failed to list files")
	}

	for {
		info, err := files.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return errors.Wrap(err, "failed to list next object")
		}

		fmt.Printf("%4d\t%s\t%d\t%s\n", info.ID(), info.Created().Format(time.RFC822), info.Size(), info.Base())
	}

	return nil
}
